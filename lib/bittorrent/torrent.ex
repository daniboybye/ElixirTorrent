defmodule Torrent do
  use Supervisor, type: :supervisor, restart: :transient

  require Logger
  require Via

  Via.make()

  @type hash :: <<_::160>>
  @type index :: non_neg_integer()
  @type begin :: non_neg_integer()
  @type length :: pos_integer()
  @type block :: binary()
  @type bitfield :: binary()

  @started 2

  @enforce_keys [:hash, :struct, :left, :last_index, :last_piece_length]
  defstruct [
    :hash,
    :struct,
    :left,
    :last_index,
    :last_piece_length,
    peer_status: nil,
    uploaded: 0,
    downloaded: 0,
    event: @started
  ]

  @type t :: %__MODULE__{
          # urlencoded 20-byte string used as a unique ID for the client, 
          # generated by the client at startup
          hash: hash(),
          struct: %{required(binary()) => map()},
          # The number of bytes this client still has to download in base
          # ten ASCII. Clarification: 
          # The number of bytes needed to download to be 100% complete 
          # and get all the included files in the torrent.
          left: non_neg_integer(),
          last_index: index(),
          last_piece_length: length(),
          peer_status: nil | :seed | index(),
          # The total amount uploaded 
          # (since the client sent the 'started' event to the tracker)"""
          uploaded: non_neg_integer(),
          # The total amount downloaded 
          # (since the client sent the 'started' event to the tracker)"""
          downloaded: non_neg_integer(),
          # "started" | "empty" | "completed" | "stopped"
          event: 0..3
        }

  def started(), do: @started

  def empty(), do: 0

  def completed(), do: 1

  def stopped(), do: 3

  @spec event_to_string(0..3) :: String.t()
  def event_to_string(0), do: "empty"

  def event_to_string(1), do: "completed"

  def event_to_string(2), do: "started"

  def event_to_string(3), do: "stopped"

  @spec get_announce_list(__MODULE__.t()) :: nonempty_list(Tracker.announce())
  def get_announce_list(%__MODULE__{} = torrent) do
    torrent.struct
    |> Map.get("announce-list", [])
    |> Enum.concat()
    |> (&[torrent.struct["announce"] | &1]).()
  end

  @spec start_link({Path.t(), Keyword.t()}) :: Supervisor.on_start() | no_return()
  def start_link({path, options}) do
    torrent = parse_file!(path)

    Registry.put_meta(
      Registry,
      {torrent.hash, :check},
      Keyword.get(options, :check, false)
    )

    Supervisor.start_link(__MODULE__, torrent, name: via(torrent.hash))
  end

  @spec has_hash?(hash()) :: boolean()
  def has_hash?(hash), do: !!GenServer.whereis(via(hash))

  defdelegate add_peer(hash, peer_id, socket), to: __MODULE__.Swarm

  defdelegate get(hash), to: __MODULE__.Server

  defdelegate torrent_downloaded?(hash), to: __MODULE__.Server

  defdelegate size(hash), to: __MODULE__.Server

  defdelegate new_peers(hash, list), to: __MODULE__.Server

  @spec get_hash(pid()) :: Torrent.hash() | nil
  def get_hash(pid) do
    with [{hash, _} | _] <- Registry.keys(Registry, pid) do
      hash
    else
      _ -> 
        nil
    end
  end

  def restart(hash) do
    Registry.put_meta(
      Registry,
      {hash, :check},
      true
    )

    Supervisor.stop(via(hash), :error)
  end

  def stop(hash), do: Supervisor.stop(via(hash))

  def init(torrent) do
    [
      {__MODULE__.Bitfield, torrent},
      {__MODULE__.PiecesStatistic, torrent},
      {__MODULE__.FileHandle, torrent},
      {__MODULE__.Uploader, torrent},
      {__MODULE__.Swarm, torrent},
      {__MODULE__.Downloads, torrent},
      {__MODULE__.Server, torrent}
    ]
    |> Supervisor.init(strategy: :one_for_all, max_restarts: 0)
  end

  defp parse_file!(path) do
    struct =
      path
      |> File.read!()
      |> Bento.decode!()

    bytes = all_bytes_in_torrent(struct)

    last_index =
      struct["info"]["pieces"]
      |> byte_size()
      |> div(20)
      |> Kernel.-(1)

    %__MODULE__{
      hash: info_hash(struct),
      left: bytes,
      last_piece_length: bytes - last_index * struct["info"]["piece length"],
      struct: struct,
      last_index: last_index
    }
  end

  defp info_hash(%{"info" => info}) do
    info
    |> Bento.encode!()
    |> (&:crypto.hash(:sha, &1)).()
  end

  defp all_bytes_in_torrent(%{"info" => %{"length" => length}}), do: length

  defp all_bytes_in_torrent(%{"info" => %{"files" => list}}) do
    Enum.reduce(list, 0, fn %{"length" => x}, acc -> x + acc end)
  end
end
