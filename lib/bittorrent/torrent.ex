defmodule Torrent do
  use Supervisor, type: :supervisor, restart: :transient

  require Logger
  require Via

  alias __MODULE__.{Server, Swarm, Bitfield, PiecesStatistic, FileHandle, Uploader, Downloads}

  Via.make()

  @compile {:inline, empty: 0, started: 0, completed: 0, stopped: 0, event_to_string: 1}

  @type hash :: <<_::160>>
  @type index :: non_neg_integer()
  @type begin :: non_neg_integer()
  @type length :: pos_integer()
  @type block :: binary()
  @type bitfield :: binary()

  @empty 0
  @completed 1
  @started 2
  @stopped 3

  @enforce_keys [:hash, :struct, :left, :last_index, :last_piece_length]
  defstruct [
    :hash,
    :struct,
    :left,
    :last_index,
    :last_piece_length,
    peer_status: nil,
    uploaded: 0,
    downloaded: 0,
    event: @started
  ]

  @type t :: %__MODULE__{
          # urlencoded 20-byte string used as a unique ID for the client, 
          # generated by the client at startup
          hash: hash(),
          struct: %{required(binary()) => map()},
          # The number of bytes this client still has to download in base
          # ten ASCII. Clarification: 
          # The number of bytes needed to download to be 100% complete 
          # and get all the included files in the torrent.
          left: non_neg_integer(),
          last_index: index(),
          last_piece_length: length(),
          peer_status: Peer.status(),
          # The total amount uploaded 
          # (since the client sent the 'started' event to the tracker)"""
          uploaded: non_neg_integer(),
          # The total amount downloaded 
          # (since the client sent the 'started' event to the tracker)"""
          downloaded: non_neg_integer(),
          # "started" | "empty" | "completed" | "stopped"
          event: 0..3
        }

  def started(), do: @started

  def empty(), do: @empty

  def completed(), do: @completed

  def stopped(), do: @stopped

  @spec event_to_string(0..3) :: String.t()
  def event_to_string(@empty), do: "empty"

  def event_to_string(@completed), do: "completed"

  def event_to_string(@started), do: "started"

  def event_to_string(@stopped), do: "stopped"

  @spec start_link({Path.t(), Keyword.t()}) :: Supervisor.on_start() | no_return()
  def start_link({path, options}) do
    torrent = parse_file!(path)

    Registry.put_meta(
      Registry,
      {torrent.hash, :check},
      Keyword.get(options, :check, false)
    )

    Supervisor.start_link(__MODULE__, torrent, name: via(torrent.hash))
  end

  @spec has_hash?(hash()) :: boolean()
  def has_hash?(hash), do: !!GenServer.whereis(via(hash))

  defdelegate add_peer(hash, peer_id, reserved, socket), to: Swarm

  defdelegate get(hash), to: Server

  defdelegate torrent_downloaded?(hash), to: Server

  defdelegate size(hash), to: Server

  defdelegate tracker_response(hash, list), to: Server

  @spec get_hash(pid()) :: Torrent.hash() | nil
  def get_hash(pid) do
    case Registry.keys(Registry, pid) do
      [{hash, _} | _] ->
        hash
      _ ->
        nil
    end
  end

  def restart(hash) do
    Registry.put_meta(
      Registry,
      {hash, :check},
      true
    )

    Supervisor.stop(via(hash), :error)
  end

  def stop(hash), do: Supervisor.stop(via(hash))

  def init(torrent) do
    [
      {Bitfield, torrent},
      {PiecesStatistic, torrent},
      {FileHandle, torrent},
      {Uploader, torrent},
      {Swarm, torrent},
      {Downloads, torrent},
      {Server, torrent}
    ]
    |> Supervisor.init(strategy: :one_for_all, max_restarts: 0)
  end

  @spec parse_file!(Path.t()) :: t() | no_return()
  def parse_file!(path) do
    struct =
      path
      |> File.read!()
      |> Bento.decode!()

    bytes = all_bytes_in_torrent(struct)

    last_index =
      struct["info"]["pieces"]
      |> byte_size()
      |> div(20)
      |> Kernel.-(1)

    %__MODULE__{
      hash: info_hash(struct),
      left: bytes,
      last_piece_length: bytes - last_index * struct["info"]["piece length"],
      struct: struct,
      last_index: last_index
    }
  end

  defp info_hash(%{"info" => info}) do
    info
    |> Bento.encode!()
    |> (&:crypto.hash(:sha, &1)).()
  end

  defp all_bytes_in_torrent(%{"info" => %{"length" => length}}), do: length

  defp all_bytes_in_torrent(%{"info" => %{"files" => list}}) do
    Enum.reduce(list, 0, fn %{"length" => x}, acc -> x + acc end)
  end
end
